# 운영체제 면접 핵심 정리

## 1. 프로세스 vs 스레드

### 프로세스 (Process)

- 운영체제로부터 **독립된 메모리 공간**을 할당받아 실행되는 프로그램의 인스턴스
- 각 프로세스는 Code, Data, Stack, Heap 영역을 별도로 가짐
- 프로세스 간 통신은 **IPC**(Inter-Process Communication) 필요

### 스레드 (Thread)

- 프로세스 내에서 실행되는 **가벼운 실행 단위**
- 같은 프로세스의 스레드끼리 **Code, Data, Heap을 공유**, Stack만 별도
- 컨텍스트 스위칭 비용이 프로세스보다 작음

### 비교표

| 항목 | 프로세스 | 스레드 |
|------|----------|--------|
| 메모리 공간 | 독립적 | 공유 (Stack만 별도) |
| 생성 비용 | 높음 | 낮음 |
| 컨텍스트 스위칭 | 느림 (TLB flush 등) | 빠름 |
| 안정성 | 하나 죽어도 다른 프로세스 영향 없음 | 하나 죽으면 전체 프로세스 영향 |
| 통신 | IPC (파이프, 소켓, 공유메모리) | 공유 메모리로 직접 통신 |
| 동기화 | 상대적으로 덜 필요 | 반드시 필요 (Race Condition) |

> **면접 포인트**: "멀티프로세스 대신 멀티스레드를 쓰는 이유?" → 자원 공유로 메모리 절약, 컨텍스트 스위칭 비용 절감, 스레드 간 통신이 간편. 단, 동기화 문제에 주의해야 한다.

---

## 2. 프로세스 메모리 구조

```
높은 주소 ┌──────────────┐
          │    Stack     │  지역 변수, 함수 호출 정보 (LIFO)
          │      ↓       │  컴파일 시 크기 결정
          ├──────────────┤
          │              │  ← 빈 공간 (Stack과 Heap이 서로를 향해 성장)
          ├──────────────┤
          │      ↑       │
          │    Heap      │  동적 할당 (malloc, new)
          ├──────────────┤
          │    BSS       │  초기화되지 않은 전역/정적 변수
          ├──────────────┤
          │    Data      │  초기화된 전역/정적 변수
          ├──────────────┤
낮은 주소 │    Code(Text)│  실행할 기계어 코드 (읽기 전용)
          └──────────────┘
```

> **Stack Overflow**: 재귀 호출이 너무 깊어지면 Stack이 Heap 영역을 침범하여 발생.

---

## 3. 프로세스 상태 전이

```
         ┌─────────┐
         │  New     │ 프로세스 생성
         └────┬─────┘
              │ admit
         ┌────▼─────┐    dispatch     ┌───────────┐
         │  Ready   │───────────────→│  Running   │
         └────▲─────┘               └──┬──┬──────┘
              │                        │  │
              │ I/O complete     exit  │  │ I/O wait
              │ or event         ┌─────▼┐ │
              │                  │Termi- │ │
              │                  │nated  │ │
         ┌────┴─────┐           └───────┘ │
         │ Waiting  │◀────────────────────┘
         │(Blocked) │
         └──────────┘
```

- **New**: 프로세스 생성됨
- **Ready**: CPU 할당 대기 중
- **Running**: CPU에서 실행 중
- **Waiting(Blocked)**: I/O 등 이벤트 대기
- **Terminated**: 실행 완료

---

## 4. CPU 스케줄링

### 선점형 vs 비선점형

| 구분 | 선점형 (Preemptive) | 비선점형 (Non-preemptive) |
|------|---------------------|--------------------------|
| 특징 | OS가 CPU를 강제로 회수 가능 | 프로세스가 자발적으로 반환 |
| 응답성 | 좋음 | 나쁨 |
| 오버헤드 | 컨텍스트 스위칭 비용 | 낮음 |
| 예시 | RR, SRT, MLFQ | FCFS, SJF |

### 주요 스케줄링 알고리즘

| 알고리즘 | 방식 | 선점 | 특징 |
|----------|------|------|------|
| **FCFS** | 먼저 온 순서대로 | X | 단순, Convoy Effect 발생 가능 |
| **SJF** | 실행 시간 짧은 것 우선 | X | 평균 대기 시간 최소, 기아(Starvation) 문제 |
| **SRT** | 남은 시간 짧은 것 우선 | O | SJF의 선점형 버전 |
| **RR** | 타임 퀀텀 단위로 순환 | O | 공정, 퀀텀 크기가 성능 좌우 |
| **Priority** | 우선순위 높은 것 우선 | 둘 다 | 기아 문제 → Aging으로 해결 |
| **MLFQ** | 다단계 피드백 큐 | O | 실제 OS에서 많이 사용 |

> **Convoy Effect**: 긴 프로세스가 CPU를 오래 점유하여 짧은 프로세스들이 기다리는 현상 (FCFS의 단점).
>
> **Starvation**: 우선순위 낮은 프로세스가 영원히 CPU를 할당받지 못하는 현상. **Aging**(대기 시간에 따라 우선순위 높이기)으로 해결.

---

## 5. 컨텍스트 스위칭 (Context Switching)

### 정의

CPU가 현재 실행 중인 프로세스/스레드를 다른 것으로 교체하는 과정.

### 과정

```
1. 현재 프로세스의 상태(레지스터, PC, SP 등)를 PCB에 저장
2. 다음 실행할 프로세스의 PCB에서 상태 복원
3. CPU가 새 프로세스 실행 시작
```

### PCB (Process Control Block)

- 프로세스 ID (PID)
- 프로세스 상태 (Ready, Running, Waiting 등)
- 프로그램 카운터 (PC)
- CPU 레지스터 값
- 메모리 관리 정보 (페이지 테이블 등)
- I/O 상태 정보
- 스케줄링 정보 (우선순위 등)

> **면접 포인트**: "컨텍스트 스위칭이 비싼 이유?" → 캐시 무효화(Cache Invalidation), TLB flush, 파이프라인 flush, PCB 저장/복원 등의 오버헤드가 발생한다.

---

## 6. 동기화 (Synchronization)

### 경쟁 조건 (Race Condition)

여러 프로세스/스레드가 공유 자원에 **동시에 접근**할 때, 실행 순서에 따라 결과가 달라지는 문제.

### 임계 영역 (Critical Section) 해결 조건

1. **상호 배제 (Mutual Exclusion)**: 한 번에 하나의 프로세스만 진입
2. **진행 (Progress)**: 임계 영역에 아무도 없으면 즉시 진입 가능
3. **한정 대기 (Bounded Waiting)**: 무한히 대기하지 않음

### 동기화 도구

| 도구 | 설명 |
|------|------|
| **Mutex** | 이진 락. 소유권 개념 (잠근 스레드만 해제 가능) |
| **Semaphore** | 카운팅 가능. 동시 접근 수 제한 (N개 허용) |
| **Monitor** | 언어 레벨 동기화 (Java의 `synchronized`) |
| **Spinlock** | 락을 얻을 때까지 busy-waiting. 짧은 임계 영역에 적합 |

### Mutex vs Semaphore

| 항목 | Mutex | Semaphore |
|------|-------|-----------|
| 값 | 0 또는 1 (이진) | 0 이상 (카운팅) |
| 소유권 | 있음 (잠근 스레드만 해제) | 없음 (누구나 signal 가능) |
| 용도 | 상호 배제 | 리소스 풀 관리, 순서 제어 |

> **면접 포인트**: "Mutex와 Binary Semaphore의 차이?" → Mutex는 소유권이 있어서 잠근 스레드만 해제 가능하고, Binary Semaphore는 소유권이 없어서 다른 스레드가 signal 가능하다. Mutex는 Priority Inheritance를 지원하여 Priority Inversion 문제를 해결할 수 있다.

---

## 7. 교착 상태 (Deadlock)

### 정의

두 개 이상의 프로세스가 서로 상대방이 점유한 자원을 기다리며 **영원히 블록**된 상태.

### 발생 조건 (4가지 모두 동시 충족 시)

1. **상호 배제 (Mutual Exclusion)**: 자원은 한 번에 하나의 프로세스만 사용
2. **점유와 대기 (Hold and Wait)**: 자원을 점유한 채로 다른 자원 대기
3. **비선점 (No Preemption)**: 강제로 자원을 빼앗을 수 없음
4. **순환 대기 (Circular Wait)**: 프로세스들이 원형으로 자원을 대기

### 해결 방법

| 방법 | 설명 | 단점 |
|------|------|------|
| **예방 (Prevention)** | 4가지 조건 중 하나를 원천 차단 | 자원 낭비, 성능 저하 |
| **회피 (Avoidance)** | 안전 상태일 때만 자원 할당 (은행원 알고리즘) | 사전 정보 필요, 오버헤드 |
| **탐지 + 복구 (Detection)** | 주기적으로 교착 감지 후 복구 | 탐지 비용, 복구 시 작업 손실 |
| **무시 (Ostrich)** | 교착이 드물면 무시 | 실제 많은 OS가 채택 (Linux) |

> **은행원 알고리즘**: 프로세스가 자원을 요청하면, 할당 후에도 시스템이 안전 상태(Safe State)인지 확인. 안전하면 할당, 아니면 거부.

---

## 8. 메모리 관리

### 가상 메모리 (Virtual Memory)

- 프로세스마다 **독립된 가상 주소 공간** 제공
- 물리 메모리보다 큰 프로그램 실행 가능
- **페이지 테이블**로 가상 주소 → 물리 주소 매핑

### 페이징 (Paging)

```
가상 주소 공간          물리 메모리
┌────────┐            ┌────────┐
│ Page 0 │──────────→│Frame 2 │
├────────┤            ├────────┤
│ Page 1 │──────┐    │Frame 0 │←── Page 3
├────────┤      │    ├────────┤
│ Page 2 │──┐   └──→│Frame 1 │
├────────┤  │        ├────────┤
│ Page 3 │──┼──────→│Frame 3 │
└────────┘  │        ├────────┤
            └──────→│Frame 5 │
                     └────────┘
```

- 가상 메모리를 **고정 크기(Page)**로 분할
- 물리 메모리를 **같은 크기(Frame)**로 분할
- 외부 단편화 없음, 내부 단편화 가능 (마지막 페이지)

### 세그멘테이션 (Segmentation)

- **가변 크기** 단위로 분할 (Code, Data, Stack 등 논리적 단위)
- 외부 단편화 발생 가능
- 실제로는 **페이징 + 세그멘테이션** 혼합 사용

### 내부 단편화 vs 외부 단편화

| 항목 | 내부 단편화 | 외부 단편화 |
|------|-------------|-------------|
| 정의 | 할당된 공간 중 사용되지 않는 부분 | 할당 가능하지만 연속적이지 않아 사용 불가 |
| 발생 | 페이징 (고정 크기 할당) | 세그멘테이션 (가변 크기 할당) |
| 해결 | 페이지 크기 최적화 | 압축(Compaction), 페이징 도입 |

---

## 9. 페이지 교체 알고리즘

물리 메모리가 가득 찼을 때, 어떤 페이지를 내보낼지 결정.

### 주요 알고리즘

| 알고리즘 | 설명 | 특징 |
|----------|------|------|
| **FIFO** | 가장 먼저 들어온 페이지 교체 | 단순, Belady's Anomaly 발생 가능 |
| **OPT** | 앞으로 가장 오래 사용되지 않을 페이지 교체 | 이론적 최적, 구현 불가 |
| **LRU** | 가장 오래 전에 사용된 페이지 교체 | 실용적 최적, 구현 비용 높음 |
| **LFU** | 사용 빈도가 가장 낮은 페이지 교체 | 초기 집중 사용 후 안 쓰이는 경우 불리 |
| **Clock** | LRU 근사. 참조 비트 + 원형 리스트 | 실제 OS에서 많이 사용 |

> **Belady's Anomaly**: FIFO에서 프레임 수를 늘렸는데 오히려 Page Fault가 증가하는 현상. LRU, OPT에서는 발생하지 않는다.

### 페이지 폴트 (Page Fault)

```
1. CPU가 가상 주소 접근
2. 페이지 테이블에서 해당 페이지가 물리 메모리에 없음 (Valid bit = 0)
3. Page Fault 발생 → OS에 트랩
4. OS가 디스크에서 해당 페이지를 물리 메모리로 로드
5. 페이지 테이블 갱신
6. 중단된 명령어 재실행
```

### TLB (Translation Lookaside Buffer)

- 페이지 테이블의 **캐시** (주소 변환 속도 향상)
- TLB Hit → 바로 물리 주소 획득
- TLB Miss → 페이지 테이블 조회 → TLB 갱신
- 컨텍스트 스위칭 시 TLB flush 필요 (비용 발생 원인)

---

## 10. 스래싱 (Thrashing)

### 정의

프로세스가 실행보다 **페이지 교체에 더 많은 시간**을 소비하는 현상.

### 원인

- 프로세스에 할당된 프레임이 너무 적음
- 멀티프로그래밍 정도가 너무 높음

### 해결

- **Working Set 모델**: 일정 시간 내 참조된 페이지 집합을 유지
- **PFF (Page Fault Frequency)**: Page Fault 비율이 높으면 프레임 추가 할당, 낮으면 회수

---

## 11. 파일 시스템

### 파일 할당 방식

| 방식 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **연속 할당** | 연속된 블록에 저장 | 순차/직접 접근 빠름 | 외부 단편화 |
| **연결 할당** | 블록마다 다음 블록 포인터 | 외부 단편화 없음 | 직접 접근 느림 |
| **인덱스 할당** | 인덱스 블록에 위치 저장 | 직접 접근 가능 | 인덱스 블록 오버헤드 |

### inode (Unix/Linux)

- 파일의 **메타데이터** 저장 (소유자, 권한, 크기, 타임스탬프)
- 데이터 블록 주소를 가리키는 포인터 포함
  - 직접 포인터 (12개)
  - 간접 포인터 (1차, 2차, 3차)
- 파일명은 inode에 없음 → **디렉터리 엔트리**가 파일명과 inode 번호를 매핑

> **하드 링크 vs 심볼릭 링크**: 하드 링크는 같은 inode를 가리킴 (같은 파일). 심볼릭 링크는 경로명을 가리킴 (바로가기). 원본 삭제 시 하드 링크는 접근 가능, 심볼릭 링크는 깨짐.

---

## 12. 인터럽트 (Interrupt)

### 종류

| 구분 | 하드웨어 인터럽트 | 소프트웨어 인터럽트 (트랩) |
|------|-------------------|---------------------------|
| 발생 원인 | 외부 장치 (키보드, 디스크 등) | 프로그램 내부 (시스템 콜, 예외) |
| 예시 | 타이머, I/O 완료, 전원 이상 | Division by zero, Page Fault, syscall |

### 인터럽트 처리 과정

```
1. 인터럽트 발생
2. 현재 실행 중인 명령어 완료
3. 현재 상태(PC, 레지스터) 저장
4. 인터럽트 벡터 테이블에서 핸들러 주소 조회
5. ISR (Interrupt Service Routine) 실행
6. 저장된 상태 복원
7. 중단된 프로세스 재개
```

---

## 13. 시스템 콜 (System Call)

### 정의

사용자 프로그램이 **커널의 서비스**를 요청하기 위한 인터페이스.

### 주요 분류

| 분류 | 시스템 콜 | 설명 |
|------|-----------|------|
| 프로세스 제어 | fork(), exec(), exit(), wait() | 프로세스 생성/실행/종료 |
| 파일 관리 | open(), read(), write(), close() | 파일 입출력 |
| 장치 관리 | ioctl(), read(), write() | 장치 제어 |
| 정보 유지 | getpid(), time(), alarm() | 시스템 정보 조회 |
| 통신 | pipe(), shmget(), mmap() | IPC |

### 사용자 모드 vs 커널 모드

| 항목 | 사용자 모드 (User Mode) | 커널 모드 (Kernel Mode) |
|------|------------------------|------------------------|
| 권한 | 제한적 (하드웨어 직접 접근 불가) | 모든 명령어 실행 가능 |
| 메모리 접근 | 자기 프로세스 영역만 | 전체 메모리 접근 |
| 전환 | 시스템 콜 → 커널 모드 | 작업 완료 후 → 사용자 모드 |

> **면접 포인트**: "fork()와 exec()의 차이?" → fork()는 현재 프로세스를 복제하여 자식 프로세스를 생성. exec()는 현재 프로세스의 메모리를 새 프로그램으로 교체. 보통 fork() 후 자식에서 exec()를 호출하여 새 프로그램을 실행한다.

---

## 14. IPC (Inter-Process Communication)

프로세스는 독립된 메모리 공간을 가지므로 통신을 위한 별도 메커니즘 필요.

| 방식 | 설명 | 특징 |
|------|------|------|
| **파이프 (Pipe)** | 단방향 바이트 스트림 | 부모-자식 프로세스 간, 단방향 |
| **Named Pipe (FIFO)** | 이름 있는 파이프 | 관계 없는 프로세스 간 통신 가능 |
| **메시지 큐** | 커널이 관리하는 메시지 저장소 | 구조화된 데이터, 비동기 |
| **공유 메모리** | 동일 메모리 영역 매핑 | 가장 빠름, 동기화 필요 |
| **소켓** | 네트워크 통신 인터페이스 | 다른 호스트 간 통신 가능 |
| **시그널** | 비동기 이벤트 알림 | 제한된 정보 (신호 번호만) |
| **Memory-mapped File** | 파일을 메모리에 매핑 | 대용량 데이터, mmap() |

> **면접 포인트**: "공유 메모리가 가장 빠른 이유?" → 커널을 거치지 않고 프로세스들이 같은 물리 메모리에 직접 접근하기 때문이다. 단, 동기화는 프로그래머가 직접 해결해야 한다.

---

## 15. I/O 모델

### 동기 vs 비동기 / 블로킹 vs 논블로킹

|  | 블로킹 | 논블로킹 |
|--|--------|----------|
| **동기** | read() 호출 → 데이터 올 때까지 대기 | read() 호출 → 즉시 리턴 → 폴링으로 확인 |
| **비동기** | (해당 없음) | aio_read() → 완료 시 콜백/시그널 |

### Linux I/O 모델 5가지

1. **Blocking I/O**: read()에서 데이터 준비될 때까지 블록
2. **Non-blocking I/O**: 즉시 리턴, 주기적으로 확인 (busy waiting)
3. **I/O Multiplexing**: select/poll/epoll로 여러 fd 감시
4. **Signal-driven I/O**: 데이터 준비 시 시그널로 알림
5. **Asynchronous I/O**: 커널이 I/O 완료 후 알림 (진정한 비동기)

### select vs poll vs epoll

| 항목 | select | poll | epoll |
|------|--------|------|-------|
| fd 수 제한 | 1024 (FD_SETSIZE) | 제한 없음 | 제한 없음 |
| 방식 | 매번 전체 fd 순회 | 매번 전체 fd 순회 | 이벤트 기반 (콜백) |
| 성능 | O(n) | O(n) | O(1) |
| 적합한 경우 | 소수 fd | 소수 fd | 대량 연결 |

> **면접 포인트**: "Java NIO가 epoll을 사용하는 이유?" → 대량의 소켓 연결을 효율적으로 관리하기 위해. Selector가 내부적으로 epoll을 사용하여 이벤트가 발생한 채널만 처리한다.

---

## 16. 캐시 (Cache)

### 캐시의 지역성 (Locality)

| 종류 | 설명 | 예시 |
|------|------|------|
| **시간적 지역성** | 최근 접근한 데이터를 다시 접근 | 반복문의 변수 |
| **공간적 지역성** | 인접한 데이터에 접근 | 배열 순차 접근 |

### CPU 캐시 계층

```
CPU ──→ L1 Cache (수 ns) ──→ L2 Cache (수십 ns) ──→ L3 Cache (수십 ns) ──→ RAM (수백 ns) ──→ Disk (ms)
         ~64KB                ~256KB                 ~수 MB                  ~수 GB            ~수 TB
```

### 캐시 교체 정책

- **LRU**: 가장 오래 전에 사용된 항목 교체
- **LFU**: 가장 적게 사용된 항목 교체
- **FIFO**: 가장 먼저 들어온 항목 교체

> **Cache Line**: CPU는 바이트 단위가 아닌 **캐시 라인(보통 64바이트)** 단위로 메모리를 가져온다. 배열 순차 접근이 빠른 이유가 여기에 있다.

---

## 17. 사용자 수준 스레드 vs 커널 수준 스레드

| 항목 | 사용자 수준 스레드 | 커널 수준 스레드 |
|------|-------------------|-----------------|
| 관리 | 사용자 라이브러리 | OS 커널 |
| 컨텍스트 스위칭 | 빠름 (커널 개입 없음) | 느림 (커널 개입) |
| 병렬 실행 | 불가 (커널은 프로세스만 인식) | 가능 (멀티코어 활용) |
| I/O 블로킹 | 하나 블록 → 전체 블록 | 하나 블록 → 다른 스레드 실행 |

### Java의 스레드 모델

- **기존 (Platform Thread)**: 1:1 매핑 (Java 스레드 = OS 커널 스레드)
- **Virtual Thread (Java 21+)**: M:N 매핑. 경량 스레드로 수백만 개 생성 가능. I/O 대기 시 캐리어 스레드를 반환하여 효율적 활용.

---

## 18. 자주 나오는 면접 질문 모음

1. **프로세스와 스레드의 차이점을 설명하세요**
2. **컨텍스트 스위칭이란 무엇이고, 왜 비용이 큰가요?**
3. **교착 상태(Deadlock)의 4가지 발생 조건은?**
4. **Deadlock을 해결하는 방법들을 설명하세요**
5. **가상 메모리란 무엇인가요?**
6. **페이지 폴트 발생 시 처리 과정을 설명하세요**
7. **LRU 페이지 교체 알고리즘을 설명하세요**
8. **내부 단편화와 외부 단편화의 차이는?**
9. **스래싱이란 무엇이고 어떻게 해결하나요?**
10. **Mutex와 Semaphore의 차이점은?**
11. **동기와 비동기, 블로킹과 논블로킹의 차이는?**
12. **CPU 스케줄링 알고리즘을 3가지 이상 설명하세요**
13. **시스템 콜이란 무엇인가요?**
14. **사용자 모드와 커널 모드의 차이는?**
15. **fork()와 exec()의 차이를 설명하세요**
16. **IPC 방식에는 어떤 것들이 있나요?**
17. **캐시의 지역성 원리를 설명하세요**
18. **TLB의 역할은 무엇인가요?**
19. **select, poll, epoll의 차이점은?**
20. **Java Virtual Thread가 기존 스레드와 다른 점은?**
