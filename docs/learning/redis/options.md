# Redis Pub/Sub 핵심 설정 가이드

"단순히 메시지만 쏘고 잊어버리니까(Fire and Forget) 설정할 게 없겠지?"라고 생각하기 쉽지만, Redis Pub/Sub 운영에서 가장 치명적인 장애 포인트가 있습니다.

> **핵심 이슈**
> **"느린 구독자(Slow Subscriber)로 인한 메모리 폭발"** 문제
> 면접관이 "Pub/Sub 운영 시 주의사항"을 물었을 때 합격/불합격을 가르는 킬러 질문입니다.

---

## 1. client-output-buffer-limit pubsub (최우선)

> **Redis Pub/Sub 시스템이 죽는 이유의 90%는 이 설정 때문입니다.**

### 문제 상황

| 역할 | 처리량 |
|------|--------|
| Publisher | 초당 10,000개 메시지 발행 |
| Subscriber | 초당 5,000개만 처리 |

- Redis는 구독자가 못 가져간 5,000개를 **Output Buffer**에 계속 적재
- 버퍼가 무제한으로 커지면 Redis 전체가 **OOM(Out of Memory)** 로 사망

### 해결 방법

버퍼가 일정 크기 이상 커지면 해당 구독자를 **강제 연결 해제(Drop)** 하도록 설정:

```conf
client-output-buffer-limit pubsub 32mb 8mb 60
```

| 조건 | 동작 |
|------|------|
| 버퍼 > 32MB | **즉시** 연결 끊음 (Hard Limit) |
| 버퍼 > 8MB 상태가 60초 지속 | 연결 끊음 (Soft Limit) |

### 면접 답변 가이드

> "Pub/Sub은 메시지를 저장하지 않지만, 구독자에게 전달되기 전까지는 메모리 버퍼에 존재합니다.
> 따라서 `client-output-buffer-limit`을 적절히 설정하여, **느린 컨슈머 하나 때문에 Redis 전체 메모리가 고갈되는 것을 방지**했습니다."

---

## 2. save "" 및 appendonly no (영속성 끄기)

Pub/Sub의 메시지는 **휘발성**입니다. Redis에 저장되지 않고 구독자에게 전달되는 즉시 사라집니다.

### 문제점

기본 설정대로 RDB나 AOF가 켜져 있으면:
- 저장할 데이터도 없는데 불필요한 백그라운드 프로세스 동작
- 불필요한 디스크 I/O 체크

### 해결 방법

```conf
# RDB 끄기
save ""

# AOF 끄기
appendonly no
```

> **주의**
> Pub/Sub과 일반 캐시(Key-Value)를 같이 쓰는 인스턴스라면 끄면 안 됩니다.
> → 보통 **Pub/Sub용 Redis는 분리해서 운영**합니다.

---

## 3. tcp-keepalive (유령 구독자 정리)

### 문제 상황

- 구독자 서버가 비정상 종료(케이블 뽑힘, 전원 나감)
- Redis는 아직 그 연결이 살아있다고 착각
- 죽은 구독자에게 계속 메시지 전송 시도 → 버퍼 메모리 증가

### 해결 방법

```conf
# 60초마다 연결 상태 확인
tcp-keepalive 60
```

죽은 연결(Dead Connection)을 빠르게 감지하고 정리하여 리소스 확보

---

## 설정 체크리스트 요약

| 항목 | 설정 | 용도 |
|------|------|------|
| **버퍼 제한 (필수)** | `client-output-buffer-limit pubsub 32mb 8mb 60` | 느린 구독자로 인한 OOM 방지 |
| **RDB 끄기** | `save ""` | 불필요한 스냅샷 제거 |
| **AOF 끄기** | `appendonly no` | 불필요한 영속성 제거 |
| **연결 체크** | `tcp-keepalive 60` | 유령 구독자 정리 |

> **복제 고려사항**
> Replica(Slave)도 하나의 구독자로 취급됩니다.
> Slave 네트워크가 느리면 Master의 버퍼가 차오르므로, Master-Slave 간 네트워크 대역폭도 신경 써야 합니다.

---

## 면접 Q&A

### Q. Redis Pub/Sub을 쓰다가 메시지 유실이 안 되는 중요한 알림 기능이 추가되었습니다. 어떻게 하시겠습니까?

**답변**:
> "Redis Pub/Sub은 'Fire and Forget' 방식이라 구독자가 오프라인이면 메시지가 유실됩니다.
>
> 유실이 없어야 한다면 **Redis Streams로 마이그레이션** 하겠습니다.
> Streams는 카프카처럼 메시지를 디스크(또는 메모리)에 저장하고, **Consumer Group** 기능을 통해 오프셋(Offset) 관리가 가능하므로, 구독자가 나중에 접속해도 지난 메시지를 읽을 수 있기 때문입니다."

---

### Q. Redis 구성 방식(Cluster vs Sentinel)은 무엇을 선택했고 왜 그랬나요?

> **핵심 포인트**: 데이터 크기와 운영 복잡도를 기준으로 선택

**답변 예시**:
> "**Redis Sentinel** 모드를 사용하여 Master 1대, Slave 2대, Sentinel 3대로 구성했습니다.
>
> 제가 다루는 데이터(세션, 포인트 락 등)의 총량이 단일 노드의 메모리 한계(예: 16GB)를 넘지 않았기 때문에, 운영 복잡도가 높은 Cluster(샤딩) 방식을 도입할 필요가 없었습니다.
>
> 대신 고가용성(HA) 확보를 위해 Sentinel을 통해 **Master 장애 시 자동으로 Slave가 승격(Failover)** 되도록 구성했습니다."

---

### Q. 메모리 관리 정책(Maxmemory-policy)은 어떻게 설정했나요?

> **핵심 포인트**: Redis가 캐시 용도인지, 영속 저장소 용도인지 구분

**답변 예시**:

| 용도 | 정책 | 이유 |
|------|------|------|
| **캐시** | `volatile-lru` | TTL이 설정된 키 중 가장 오래된 것부터 삭제. 유효기간 없는 중요 데이터 보호 |
| **분산락** | `noeviction` | 데이터 삭제 시 동시성 이슈 발생 가능. 메모리 가득 차면 에러 반환 |

---

### Q. Redis 데이터 영속성(RDB, AOF) 설정은 했나요?

> **핵심 포인트**: 성능과 데이터 보존 사이의 트레이드오프

**답변 예시**:
> "장애 발생 시 빠른 복구를 위해 **RDB + AOF 혼합** 사용했습니다.
>
> | 방식 | 설정 | 용도 |
> |------|------|------|
> | RDB | 15분마다 스냅샷 | 백업용 |
> | AOF | `appendfsync everysec` | 1초 단위 저장, 최대 1초 이내 데이터 유실 방어 |
>
> 단, 단순 조회수 카운팅이나 Pub/Sub 메시징 큐 용도의 Redis는 성능을 위해 영속성 설정을 끄고 운영하기도 했습니다."
