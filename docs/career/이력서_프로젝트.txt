================================================================================
                         프로젝트 경력 기술서 (이력서용)
================================================================================

【 1. Vueroid Cloud - IoT 클라우드 플랫폼 】

▶ 기간: [프로젝트 기간 기입]
▶ 역할: 백엔드 개발 (실시간 통신 아키텍처 설계 및 구현)
▶ 기술 스택: Java, Spring Boot, Redis, MQTT, WebSocket, Spring Batch

▶ 주요 성과:

  • 실시간 통신 서버 Scale-Out 아키텍처 설계
    - Redis Pub/Sub 기반 WebSocket 세션 클러스터링 구현
    - 단일 서버 한계를 극복하여 수평 확장 가능한 구조로 전환
    - 다중 서버 환경에서 실시간 메시지 동기화 보장
    → 서버 증설 시에도 무중단으로 트래픽 분산 처리 가능

  • IoT 디바이스 대규모 연동 시스템 구축
    - MQTT 프로토콜 도입으로 경량화된 디바이스 통신 환경 구축
    - 수천 대 디바이스의 동시 접속 및 실시간 상태 모니터링 지원
    → 기존 HTTP Polling 대비 네트워크 트래픽 80% 절감

  • 대용량 데이터 배치 처리 시스템 개발
    - Spring Batch 기반 정기 데이터 집계 파이프라인 구축
    - 청크 단위 처리 및 병렬 실행으로 시스템 부하 분산
    → 일 100만 건 이상의 데이터 안정적 처리


--------------------------------------------------------------------------------

【 2. Blur - 핀테크 결제/포인트 플랫폼 】

▶ 기간: [프로젝트 기간 기입]
▶ 역할: 백엔드 개발 (결제 코어 시스템 설계 및 구현)
▶ 기술 스택: Java, Spring Boot, PostgreSQL, JPA

▶ 주요 성과:

  • 포인트 결제 시스템 동시성 제어 아키텍처 설계
    - 비관적 락(SELECT FOR UPDATE) 기반 Row-Level Locking 적용
    - 동시 다발적 결제 요청에서 100% 데이터 정합성 보장
    - 포인트/금액 관련 민감 데이터의 무결성 확보
    → 동시 결제 요청 시 Race Condition 완전 해결

  • 복합 비즈니스 로직 쿼리 최적화 (무료/유료 포인트 차감)
    - CTE(Common Table Expression) + CASE 문 활용한 단일 쿼리 설계
    - 애플리케이션-DB 간 Round-trip 최소화
    - DB 락 유지 시간 단축으로 처리량(Throughput) 향상
    → 기존 다중 쿼리 대비 응답 시간 60% 개선

  • 트랜잭션 격리 수준 최적화
    - 비즈니스 요구사항에 따른 적절한 격리 수준 적용
    - 데드락 방지를 위한 락 순서 표준화
    → 결제 실패율 0.01% 미만 달성


--------------------------------------------------------------------------------

【 3. ADAS Dataset - 자율주행 데이터 관리 플랫폼 】

▶ 기간: [프로젝트 기간 기입]
▶ 역할: 백엔드 개발 (대용량 데이터 조회 API 설계 및 최적화)
▶ 기술 스택: Java, Spring Boot, QueryDSL, PostgreSQL

▶ 주요 성과:

  • 대용량 데이터 조회 성능 개선
    - 기존 Offset 기반 → No-Offset(Cursor-based) 페이징 전환
    - Full Table Scan 제거로 조회 성능 극대화
    → 100만 건 이상 데이터에서 조회 속도 10배 이상 개선 (2초 → 0.2초)

  • 데이터 정합성 보장 커서 설계
    - 복합 커서(Composite Cursor) 전략 적용 (timestamp + PK)
    - 동일 시간 데이터 간 누락/중복 조회 완전 방지
    - (created_at, id) 복합 인덱스 최적화
    → 페이징 정확도 100% 보장

  • 동적 검색 쿼리 최적화
    - QueryDSL 기반 타입 세이프 동적 쿼리 구현
    - 복잡한 필터 조건의 효율적 처리
    - 인덱스 전략 수립 및 실행 계획 분석
    → 복합 조건 검색 응답 시간 70% 단축


--------------------------------------------------------------------------------

【 4. Taxi-BSD - 택시 비즈니스 관리 시스템 】

▶ 기간: [프로젝트 기간 기입]
▶ 역할: 풀스택 개발 (서비스 아키텍처 설계 및 API 개발)
▶ 기술 스택: Java, Spring Boot, JPA, PostgreSQL

▶ 주요 성과:

  • 서비스 아키텍처 설계
    - 비즈니스 요구사항 분석 및 도메인 모델링
    - 확장성을 고려한 RDBMS 스키마 설계 (정규화/반정규화)
    - 엔티티 관계 설계 및 인덱스 전략 수립

  • RESTful API 설계 및 구현
    - REST 원칙에 기반한 API 명세 설계
    - 클라이언트 친화적인 응답 구조 표준화
    - API 버저닝 및 에러 핸들링 체계 구축


--------------------------------------------------------------------------------

【 5. Vueroid-Line - 생산라인 모니터링 시스템 】

▶ 기간: [프로젝트 기간 기입]
▶ 역할: 백엔드 개발 (레거시 시스템 현대화 및 유지보수)
▶ 기술 스택: Java, Spring Boot, JPA

▶ 주요 성과:

  • 레거시 코드 현대화 리팩토링
    - 기존 절차적 코드를 객체지향 설계로 전환
    - 비즈니스 로직 분리 및 테스트 용이성 확보
    - 코드 품질 향상 및 유지보수성 개선

  • REST API 안정화 및 성능 개선
    - 기존 API 응답 시간 최적화
    - 에러 핸들링 및 로깅 체계 개선


================================================================================
                              기술 역량 요약
================================================================================

【 Backend 】
  • Java, Spring Boot, Spring Batch, Spring Data JPA
  • RESTful API 설계 및 구현
  • 동시성 제어 (비관적/낙관적 락, 트랜잭션 관리)

【 Database 】
  • PostgreSQL, MySQL
  • 쿼리 최적화 (실행 계획 분석, 인덱스 튜닝)
  • 대용량 데이터 처리 (커서 기반 페이징, 배치 처리)

【 실시간 통신 】
  • WebSocket, MQTT
  • Redis Pub/Sub 기반 분산 세션 관리

【 Architecture 】
  • 확장 가능한 서버 아키텍처 설계
  • 데이터 모델링 및 스키마 설계


================================================================================
                           면접 예상 질문 & 답변
================================================================================

Q1. Redis Pub/Sub vs Kafka 선택 이유?
→ "실시간 채팅/알림처럼 메시지 유실이 크리티컬하지 않고, 즉시성이 중요한
   상황이었습니다. Kafka 대비 운영 복잡도가 낮고, 이미 캐시로 Redis를
   사용하고 있어 인프라 단순화 측면에서 Redis Pub/Sub을 선택했습니다.
   다만, 메시지 영속성이 필요한 경우 Kafka 도입을 검토했을 것입니다."

Q2. 비관적 락 vs 낙관적 락 선택 기준?
→ "포인트/결제와 같이 데이터 정합성이 최우선인 경우 비관적 락,
   충돌 빈도가 낮고 재시도가 허용되는 경우 낙관적 락을 선택합니다.
   해당 프로젝트는 금전 관련 민감 데이터였고, 충돌 시 재시도보다
   확실한 순차 처리가 중요하여 비관적 락을 적용했습니다."

Q3. 커서 기반 페이징에서 정렬 기준 중복 처리?
→ "timestamp와 PK를 복합 커서로 사용했습니다. ORDER BY created_at DESC,
   id DESC로 정렬하고, WHERE 절에서 (created_at < cursor) OR
   (created_at = cursor AND id < cursor_id) 조건으로 정확한 다음
   페이지를 조회했습니다."

Q4. 쿼리 내부에서 비즈니스 로직 처리한 이유?
→ "DB 락 유지 시간을 최소화하기 위해서입니다. 데이터를 애플리케이션으로
   가져와 계산 후 업데이트하면 락 시간이 길어지는데, 쿼리 내부에서
   한 번에 처리하면 락 유지 시간을 줄이고 동시 처리량을 높일 수 있습니다."

================================================================================
