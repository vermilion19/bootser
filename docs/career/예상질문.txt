1. MQTT vs WebSocket: 차량 환경에서의 결정적 차이 3가지
면접 답변 시 이 세 가지 키워드를 중심으로 설명하세요: "재연결 비용", "신뢰성(QoS)", "N:M 통신 패턴"

① 연결 복구와 세션 유지 (Session Takeover)
WebSocket: 웹 브라우저를 위해 만들어졌습니다. 터널에 들어가서 연결이 끊기면, 다시 3-Way Handshake를 하고 HTTP 업그레이드 요청을 보내는 무거운 재연결 과정이 필요합니다. 연결이 끊긴 동안의 데이터는 애플리케이션 레벨에서 직접 관리하지 않으면 사라집니다.

MQTT: Clean Session = false 옵션을 사용하면, 기기가 잠깐 연결이 끊겼다 다시 붙어도 브로커가 "아, 너 아까 걔구나"라고 바로 인식합니다. 재연결 오버헤드가 극도로 적고, 끊겨 있던 동안의 메시지도 브로커가 보관했다가 다시 줍니다. (차량 환경 필수 기능)

② 신뢰성 보장 (QoS vs 직접 구현)
WebSocket: 기본적으로 **"보내고 끝(Fire and Forget)"**이거나 TCP에 의존합니다. "메시지가 진짜 도착했는지 확인하고, 안 갔으면 재전송해라"라는 로직(ACK, Retry)을 개발자가 직접 코드로 다 짜야 합니다.

MQTT: 프로토콜 레벨에서 QoS 1(적어도 한 번 전송), QoS 2(정확히 한 번 전송)를 지원합니다. 설정값 하나로 메시지 도달을 보장할 수 있는데, 굳이 웹소켓 위에서 바퀴를 다시 발명(Reinventing the wheel)할 필요가 없다고 판단했습니다.

③ Pub/Sub 패턴의 유연성
WebSocket: 기본적으로 1:1(Point-to-Point) 통신입니다. 채팅방처럼 N:M 통신을 하려면 STOMP 같은 서브 프로토콜을 또 얹어야 해서 헤더가 무거워집니다.

MQTT: 태생이 Pub/Sub입니다. 서버가 몇 대가 되든, 기기가 몇 대가 되든 토픽(Topic) 기반으로 완벽하게 결합도(Coupling)가 분리되어 있어 서버 확장에 훨씬 유리합니다.



면접관에게 **"무지성으로 MQTT를 고른 게 아니라, 다 비교해 보고 최적의 선택을 했다"**는 것을 보여주는 답변입니다.

[답변 예시]

"네, 프로젝트 설계 초기 단계에서 HTTP Polling, SSE(Server-Sent Events), WebSocket을 비교 검토했습니다.

HTTP Polling: 차량 수천 대가 초 단위로 서버에 요청을 보내는 것은 서버 리소스를 너무 낭비하고 실시간성도 떨어진다고 판단해 제외했습니다.

SSE: 서버에서 차량으로 명령을 내리는 건 좋지만, 차량에서 서버로 데이터를 보내는 것이 불가능한 단방향 통신이라 제외했습니다.

WebSocket: 가장 강력한 경쟁 후보였습니다. 하지만 다음 세 가지 이유로 MQTT가 더 적합하다고 결론 내렸습니다.

첫째, 헤더 크기입니다. 웹소켓은 초기 핸드쉐이크가 무겁지만, MQTT는 최소 2바이트 헤더로 동작해 LTE 데이터 비용 절감에 유리합니다.

둘째, 구현 복잡도입니다. 터널 진입 등으로 네트워크가 끊겼을 때의 '메시지 보관 및 재전송(QoS)' 로직을 웹소켓으로 직접 구현하는 것보다, MQTT의 검증된 QoS 기능을 쓰는 것이 안정적이라 판단했습니다.

셋째, 배터리 효율입니다. 모바일 환경에 최적화된 MQTT가 Keep-Alive 패킷 관리가 더 효율적이어서, 차량 배터리(주차 녹화 모드 등) 소모를 줄이는 데 유리합니다.

결론적으로, 웹이 아닌 임베디드/모바일 환경의 불확실성을 커버하기에는 MQTT가 최적의 선택이었습니다."

마지막으로 기술적 깊이를 보여주는 멘트를 덧붙이세요.

"물론, 웹 기반의 관제 대시보드(어드민 페이지)에서는 브라우저 호환성을 위해 MQTT over WebSocket을 사용하여, 브라우저가 별도의 변환 서버 없이 MQTT 브로커와 직접 통신할 수 있도록 아키텍처를 유연하게 가져갔습니다."

설명: MQTT는 TCP 위에서 돌지만, 웹소켓 위에서도 돌 수 있습니다. (NanoMQ도 지원함). 이걸 언급하면 "아, 이 친구는 웹(프론트)과 기기(임베디드)의 차이를 명확히 아는구나"라고 생각하게 됩니다.


단순히 "패킷이 작아서요"라고 답하는 것을 넘어, **배터리 소모 원리(Radio Wake-up)**와 프로토콜 설계의 차이로 설명해야 시니어다운 답변이 됩니다.

면접관을 설득할 수 있는 3가지 핵심 이유를 정리해 드립니다.

1. "2바이트"의 마법 (Protocol Overhead)
가장 직관적인 차이는 데이터의 크기입니다.

MQTT (PINGREQ):

MQTT의 Keep-Alive 패킷(PINGREQ)은 정확히 2바이트입니다. (11000000 00000000)

더 줄일 수 없는, 물리적인 최소 단위입니다. 추가적인 헤더나 페이로드가 아예 없습니다.

WebSocket (Ping Frame vs App-level Ping):

Ping Frame (표준): 웹소켓도 스펙상 Ping/Pong 프레임(제어 프레임)이 존재하며 약 2~6바이트로 매우 작습니다. 하지만...

App-level Ping (현실): 많은 웹소켓 라이브러리나 브라우저 JS API가 Ping 프레임을 개발자에게 직접 노출하지 않습니다. 그래서 개발자들은 보통 JSON으로 하트비트를 직접 구현합니다.

예: {"type": "ping", "timestamp": 17000000} -> 약 40~50바이트 이상

결과적으로 MQTT가 수십 배 더 가벼운 데이터를 보냅니다.

2. 모바일 네트워크의 "RRC 상태"와 배터리 (핵심)
이 부분이 차량용/모바일 개발자로서 가장 중요한 지식입니다.

스마트폰이나 LTE 모뎀은 배터리를 아끼기 위해 RRC(Radio Resource Control) 상태를 가집니다.

IDLE: 데이터 전송 없음. (저전력)

CONNECTED: 데이터 전송 중. (고전력)

데이터를 1바이트라도 보내려면, 모뎀은 IDLE → CONNECTED로 깨어나야 합니다. 이때 전력을 많이 씁니다. 그리고 데이터를 다 보낸 후에도, "혹시 더 보낼 거 있나?" 하고 일정 시간(Tail Time) 동안 고전력 상태를 유지하다가 다시 잡니다.

MQTT의 효율성:

패킷이 극도로 작기 때문에 전송 시간이 짧습니다.

프로토콜 레벨에서 **Keep-Alive 주기(Interval)**를 아주 정교하게(초 단위) 설정할 수 있습니다.

통신사 NAT 타임아웃(보통 1분~5분)이 끊기지 않을 정도로만 최소한의 횟수로 깨어나도록 튜닝하기가 매우 쉽습니다.

3. 처리 로직의 단순성 (CPU Cycle = Battery)
MQTT:

브로커와 클라이언트는 2바이트(0xC0 0x00)만 확인하면 됩니다. 비트 연산 한 번이면 끝납니다. 임베디드 기기의 CPU를 거의 쓰지 않습니다.

WebSocket:

프레임을 받으면 마스킹(Masking)을 해제하고, 페이로드를 파싱해야 합니다.

만약 JSON으로 직접 핑을 구현했다면? 문자열을 파싱해서 JSON 객체로 만들고 내용을 확인해야 합니다. 이 과정에서 CPU 사이클을 더 소모하고, 이는 곧 배터리 소모로 이어집니다.

[면접용 답변 요약]
면접관에게 이렇게 설명하시면 됩니다.

"웹소켓도 Ping 프레임이 있지만, MQTT의 Keep-Alive 관리가 더 효율적인 이유는 패킷 사이즈와 구현의 강제성 때문입니다.

최소한의 데이터: MQTT의 PINGREQ는 헤더 포함 단 2바이트입니다. 반면 웹소켓은 라이브러리 제약상 애플리케이션 레벨에서 JSON 핑을 보내는 경우가 많아 오버헤드가 큽니다.

배터리 효율: 모바일 네트워크(LTE) 환경에서는 데이터를 전송할 때마다 무선 칩셋(Radio)이 고전력 상태로 깨어납니다(Wake-up). MQTT는 가장 작은 패킷으로, NAT가 끊기지 않을 최소한의 주기로만 통신하여 Radio 사용 시간과 Tail Time 전력 소모를 최소화할 수 있습니다.

차량의 배터리 방전을 막아야 하는 대시캠 환경에서는, 이러한 미세한 효율성 차이가 중요하다고 판단했습니다."

이 정도 깊이면 면접관도 "네트워크 레벨까지 고민했구나"라고 인정할 것입니다.

--
**"그냥 문자열 그대로 토스(Pass-through)하면 CPU도 안 쓰고 제일 빠른데, 굳이 왜 Gatherer에서 파싱하고 검증해서 CPU를 낭비했나요?"**

논리 1. "확장성을 위한 표준화 (Normalization)" [가장 강력한 답변]
"Gatherer의 역할은 단순 수집이 아니라, 외부 의존성을 격리하는 '부패 방지 계층(Anti-Corruption Layer)'이기 때문입니다."

상황: 지금은 업비트 하나지만, 나중에 **바이낸스(Binance), 빗썸(Bithumb)**이 추가된다면?

문제: 업비트는 trade_price라고 주고, 바이낸스는 p(price)라고 줍니다. 이걸 그대로 Pass-through 해서 내부 시스템(Redis, API 서버, DB)까지 흘려보내면, 내부의 모든 로직이 외부 거래소의 JSON 포맷에 의존하게 됩니다.

해결: Gatherer가 **"어디서 들어오든 우리 시스템 내부 표준 포맷(Canonical Model)으로 변환"**해서 넘겨줘야 합니다.

답변 예시:

"만약 Raw 데이터를 그대로 내부망에 흘리면, API 서버가 업비트, 바이낸스, 빗썸의 JSON 형식을 모두 알고 있어야 합니다. 저는 Gatherer가 '통역사' 역할을 해야 한다고 판단했습니다. 외부 데이터가 들어오는 즉시 우리 서비스의 표준 규격(DTO/Protobuf)으로 변환하여, 하위 시스템들은 거래소가 어디인지 몰라도 되게끔 **결합도(Coupling)**를 끊었습니다."

논리 2. "네트워크 및 메모리 비용 절감 (Filtering)"
"불필요한 데이터가 내부망을 점유하는 것을 막기 위해서입니다."

상황: 업비트가 보내주는 JSON에는 timestamp, stream_type, sequential_id 등 우리가 화면에 안 보여줄 데이터도 잔뜩 들어있습니다. (약 30~40%가 불필요한 필드)

문제: 이걸 그대로 Redis에 저장하고 API 서버로 보내면, 안 쓰는 데이터 때문에 Redis 메모리 비용과 네트워크 대역폭(Bandwidth)이 낭비됩니다.

해결: Gatherer에서 필요한 필드(현재가, 등락률 등)만 딱 뽑아서(Parsing & Filtering) 다시 조립해 보내는 게 전체 인프라 비용 면에서 이득입니다.

답변 예시:

"업비트 응답 패킷을 분석해 보니 실제 서비스에 필요한 필드는 전체의 60% 수준이었습니다. Raw 데이터를 그대로 Redis에 저장하면 불필요한 필드 때문에 메모리와 네트워크 대역폭 낭비가 발생한다고 판단했습니다. 그래서 Gatherer에서 필요한 데이터만 정제(Filtering)하여 페이로드 크기를 줄였습니다."

논리 3. "데이터 무결성 보장 (Fail-Fast)"
"쓰레기 데이터가 하류 시스템(Downstream)을 오염시키는 것을 입구 컷 하기 위해서입니다."

상황: 만약 업비트 오류로 가격에 null이 오거나 -1 같은 이상한 값이 온다면?

문제: 이걸 그대로 흘려보내면, 프론트엔드 차트가 깨지거나 자동매매 로직이 오작동해서 금전적 손실이 날 수 있습니다. 에러는 발생한 곳에서 가장 가까운 곳에서 잡아야 합니다.

해결: Gatherer가 "가격은 0보다 커야 한다", "코인 코드는 필수다" 같은 기본 검증을 수행하고, 이상하면 버려야 합니다.

답변 예시:

"잘못된 데이터(Poison Pill)가 DB나 클라이언트까지 도달하면 장애 파급력이 커집니다. 저는 Gatherer를 **데이터 유입의 관문(Gatekeeper)**으로 정의하고, 스키마 검증을 통과한 신뢰할 수 있는 데이터만 내부 시스템으로 전파하도록 설계했습니다."

[면접 시나리오 요약]
면접관: "Gatherer에서 왜 굳이 파싱 비용을 들였나요?"

작성자님: "네, 단순히 문자열을 넘기는 게 당장의 성능은 빠를 수 있습니다. 하지만 저는 시스템의 유지보수성과 데이터 품질이 더 중요하다고 판단했습니다.

첫째, 확장성입니다. 추후 바이낸스 등 타 거래소가 추가될 때 내부 시스템 변경 없이 Gatherer만 수정하면 되도록 표준 포맷으로 정규화했습니다.

둘째, 비용 최적화입니다. 불필요한 필드를 제거하여 Redis와 네트워크 대역폭을 절약했습니다.

셋째, 안정성입니다. 잘못된 데이터가 유입되는 것을 입구에서 차단(Fail-Fast)했습니다.

이 과정에서 발생한 CPU 부하(JSON 파싱 비용)가 병목이 되는 것을 확인했고, 이를 해결하기 위해 **gRPC(Protobuf)**를 도입하여 직렬화 비용과 데이터 크기를 동시에 잡는 방식으로 최적화했습니다."

---
"단순히 Redis가 좋아서 썼는지" 아니면 **"다른 대안들의 한계를 명확히 알고, 트레이드오프(Trade-off) 끝에 Redis를 선택했는지"

면접관이 집요하게 물어본다는 것은 "단순히 Redis가 좋아서 썼는지" 아니면 **"다른 대안들의 한계를 명확히 알고, 트레이드오프(Trade-off) 끝에 Redis를 선택했는지"**를 검증하려는 것입니다.

시니어 엔지니어처럼 보이기 위한 논리적인 방어 시나리오를 정리해 드립니다. 이 흐름대로 답변하면 면접관도 고개를 끄덕일 수밖에 없습니다.

🗣️ 답변 전략: "소거법"으로 접근하세요
처음부터 "Redis가 빠르니까요!"라고 하지 말고, "다른 방법들이 왜 이 프로젝트(선착순 대용량 트래픽)에 안 맞는지" 하나씩 설명하고, **"그래서 Redis가 최선이었다"**는 결론으로 가야 합니다.

1단계: Java synchronized를 안 쓴 이유
Q: "그냥 자바에서 제공하는 synchronized 쓰면 안 되나요? 간단하잖아요."

A: "네, 단일 서버라면 그게 가장 빠르고 간단합니다. 하지만 저희 서비스는 다중 서버(Scale-out) 환경을 전제로 설계했습니다. 자바의 동기화는 하나의 프로세스(JVM) 안에서만 유효하기 때문에, 서버가 2대 이상 늘어나는 순간 서로 다른 서버 들어오는 요청 간의 동시성을 전혀 제어할 수 없게 됩니다. 그래서 분산 환경에서 공통으로 제어할 수 있는 외부 저장소가 필요했습니다."

2단계: DB 비관적 락(Pessimistic Lock)을 안 쓴 이유
Q: "그럼 DB에도 락 기능(SELECT FOR UPDATE) 있잖아요. ACID도 보장되고 확실한데 왜 안 썼나요?"

A: "데이터 정합성은 확실하지만, 성능 이슈 때문에 배제했습니다. 선착순 이벤트는 순식간에 수만 건의 트래픽이 몰립니다. 비관적 락을 걸면 락을 획득하기 위해 수많은 스레드가 대기하게 되고, 이는 곧 DB 커넥션 풀(Connection Pool) 고갈로 이어집니다. 이벤트 트래픽 때문에 DB가 멈추면, 이벤트와 상관없는 일반 주문이나 회원가입 같은 다른 핵심 비즈니스까지 마비될 위험이 있어 DB 부하를 최소화해야 했습니다."

3단계: DB 낙관적 락(Optimistic Lock)을 안 쓴 이유
Q: "그럼 락을 안 거는 낙관적 락(Version)을 쓰면 DB 부하도 적잖아요?"

A: "낙관적 락은 충돌이 적은 상황에서는 효율적이지만, 선착순처럼 충돌이 빈번한 상황에서는 오히려 독이 됩니다. 예를 들어 재고가 1개 남았는데 1000명이 동시에 누르면, 1명만 성공하고 999명은 실패(Rollback)합니다. 실패한 999명이 재시도(Retry)를 하는 순간 DB에는 엄청난 양의 롤백 처리와 재시도 요청 트래픽이 폭주하게 되어 성능이 급격히 저하됩니다. 사용자 경험 측면에서도 '계속 실패하다가 겨우 성공'하는 것보다, Redis로 앞에서 빠르게 끊어주는 게 낫다고 판단했습니다."

4단계: 왜 Redis인가? (최종 결정)
Q: "그래서 Redis를 선택했다?"

A: "네, 맞습니다.

In-Memory 속도: 디스크 I/O가 발생하는 DB보다 압도적으로 빨라서 대용량 트래픽 처리에 적합합니다.

싱글 스레드 특성: Redis는 기본적으로 싱글 스레드로 동작하므로, 별도의 복잡한 락 구현 없이도 순차적 처리가 보장됩니다.

Lua Script의 원자성: 특히 저는 단순 SETNX 락보다는 Lua Script를 사용했습니다. '조회(Get)'와 '차감(Decr)' 로직을 네트워크 통신 한 번에 원자적으로 처리함으로써, 락을 걸고 해제하는 오버헤드조차 없앴습니다."

💡 (중요) 면접관의 역공 대비 (필살기)
면접관이 여기서 한 번 더 꼬아서 물어볼 수 있습니다. 미리 준비해두세요.

Q: "Redis도 결국 터지면(SPOF) 어떡할 건가요? 데이터 다 날아가잖아요."

A (시니어다운 답변): "맞습니다. Redis는 휘발성 메모리라 데이터 유실 위험이 있습니다. 그래서 저는 **'Redis는 수문장 역할만 한다'**는 전략을 취했습니다. Redis는 트래픽을 걸러내는 역할만 하고, 발급 성공한 내역은 즉시 **Kafka를 통해 비동기로 DB에 영구 저장(Persistence)**합니다. 또한, Redis가 죽는 최악의 상황을 대비해, **DB에 유니크 인덱스(coupon_id, user_id)**를 걸어두어 최종적으로 데이터 정합성이 깨지지 않도록 이중 안전장치를 마련했습니다."

요약 노트 (이것만 외우세요)
자바 락: 서버 늘리면(Scale-out) 못 씀.

DB 비관적 락: 대기 줄이 길어져서 DB 커넥션 말라비틀어짐 (서비스 전체 장애).

DB 낙관적 락: 재시도(Retry) 폭풍 때문에 DB가 더 힘들어함.

Redis: 메모리라 빠르고, 싱글 스레드라 순서 보장됨. 특히 Lua Script로 락 오버헤드까지 줄임.

안전장치: 그래도 불안해서 Kafka + DB 유니크 키로 2차 방어선 구축함.

이렇게 대답하면 면접관도 더 이상 공격할 곳이 없을 겁니다. 자신감을 가지세요!