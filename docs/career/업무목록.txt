경력 기술서 (상세 버전)
1. Vueroid Cloud

주요 역할: 백엔드 API 개발 및 실시간 통신 서버 구축
기술 스택: Java, Spring Boot, Redis, MQTT, WebSocket
상세 내용:
웹소켓 서버 이중화 및 확장성 확보: 단일 서버의 한계를 극복하기 위해 Redis Pub/Sub 기능을 활용하여 다중 서버 환경에서도 웹소켓 세션이 유기적으로 연동되도록 아키텍처 설계 및 구현
IoT 디바이스 통신 최적화: MQTT 프로토콜을 도입하여 디바이스와 서버 간의 경량화된 메시지 송수신 환경 구축
대용량 데이터 배치 처리: Spring Batch를 활용하여 정기적인 데이터 집계 및 처리 로직을 구현하고 시스템 부하 분산

2. Blur

주요 역할: 결제 및 포인트 시스템 코어 로직 개발
기술 스택: Java, Spring Boot, PostgreSQL
상세 내용:
동시성 이슈(Concurrency) 해결: 포인트 차감 시 **SELECT ... FOR UPDATE를 활용한 비관적 락(Pessimistic Lock)**을 적용하여 동시 다발적인 요청에도 데이터 정합성을 완벽하게 보장 (Row-Level Locking)
복합 비즈니스 로직 쿼리 최적화: 무료 포인트 우선 차감 및 잔액 검증 로직을 **CTE(Common Table Expression)**와 CASE 문을 활용한 단일 쿼리로 구현하여 애플리케이션과 DB 간의 왕복(Round-trip) 횟수 최소화

이 코드와 관련된 예상 질문 (업데이트)
면접관이 이 쿼리를 본다면 이런 질문을 할 확률이 매우 높습니다.

Q: FOR UPDATE를 쓰면 락이 걸려서 성능 저하(데드락이나 타임아웃) 우려가 있었을 텐데, 낙관적 락(Optimistic Lock, 버전 관리)을 고려하지 않고 비관적 락을 선택한 이유는 무엇인가요?

답변 가이드: "포인트/돈과 관련된 민감한 데이터라 충돌 발생 시 재시도 로직보다 데이터의 정합성을 최우선으로 했습니다. 또한, 한 유저에 대한 포인트 갱신 요청이 밀리초 단위로 수십 건씩 겹치는 상황보다는, 확실하게 순차 처리하는 것이 중요하다고 판단했습니다."

Q: 쿼리 내부에서 무료/유료 포인트를 나누는 로직(CASE WHEN)을 처리하셨는데, 이를 자바 애플리케이션 계층에서 처리하지 않고 DB 쿼리로 내린 이유는 무엇인가요?

답변 가이드: "DB 락을 잡고 있는 시간을 최소화하기 위해서입니다. 데이터를 애플리케이션으로 가져와서 계산하고 다시 업데이트하면 그 시간만큼 락이 길어지는데, 쿼리 내부에서 한 번에 처리하면 락 유지 시간을 줄이고 성능을 높일 수 있습니다."

3. ADAS Dataset

주요 역할: 대용량 데이터 관리 API 개발

기술 스택: Java, Spring Boot, QueryDSL

상세 내용:

대용량 데이터 조회 성능 개선: 기존 Offset 기반 페이징의 성능 저하(Full Scan) 문제를 해결하기 위해 No-Offset(Cursor-based) 페이징 방식을 도입하여 조회 속도를 획기적으로 개선
데이터 누락 없는 페이징 구현: 정렬 기준 컬럼(예: 생성일시)이 중복될 경우를 대비해 고유 식별자(PK)를 보조 정렬 키로 포함하는 복합 커서(Composite Cursor) 전략을 사용하여 데이터 누락 및 중복 조회를 방지
쿼리 최적화: 복잡한 검색 조건을 효율적으로 처리하기 위해 QueryDSL을 활용하여 동적 쿼리 구현 및 인덱스 최적화 수행

[면접 대비] ADAS Dataset 커서 중복 문제에 대한 답변 가이드
면접관이 **"정렬 기준(생성일시)이 중복될 때 커서 설계를 어떻게 하셨나요?"**라고 물어보면 아래와 같이 답변하시면 됩니다. 가장 표준적이면서도 확실한 방법입니다.

답변 전략: "Unique Key(PK)를 서브 정렬 조건으로 사용했습니다."

"네, 말씀하신 대로 생성일시(created_at)만으로 페이징을 하면 시간이 같은 데이터 사이에서 누락이나 중복이 발생할 수 있습니다.
이를 해결하기 위해 저는 생성일시와 테이블의 PK(ID)를 묶어서 복합 조건으로 커서를 설계했습니다.
즉, ORDER BY created_at DESC, id DESC와 같이 PK를 2차 정렬 기준으로 두어서, 시간이 같더라도 ID 값을 통해 항상 고유한 순서가 보장되도록 구현했습니다.
쿼리의 WHERE 절에서는 (created_at < cursor_time) OR (created_at = cursor_time AND id < cursor_id)와 같은 조건을 사용하여 정확한 다음 페이지를 조회했습니다."

4. Taxi-BSD

주요 역할: 서비스 아키텍처 설계 및 API 개발

상세 내용:
데이터 모델링: 비즈니스 요구사항을 분석하여 확장성을 고려한 RDBMS 테이블 구조 설계 및 정규화 수행
API 개발: 클라이언트와의 효율적인 통신을 위한 RESTful API 명세 설계 및 구현

5. Vueroid-Line

주요 역할: 서비스 기능 구현 및 유지보수

상세 내용:
비즈니스 로직에 기반한 안정적인 REST API 개발 및 레거시 코드 리팩토링 수행



작성 팁 (추가 보완할 점)
수치 추가: 가능하다면 구체적인 수치를 넣어주세요. (예: "조회 속도 00% 개선", "동시 접속자 00명 처리" 등)
구체적 해결 방법 명시: Blur 프로젝트의 동시성 문제 해결 부분에서 구체적으로 어떤 락(Lock) 전략을 사용했는지(Java의 synchronized, DB의 PESSIMISTIC_LOCK, Redis의 Redisson 등) 명시하면 신뢰도가 크게 올라갑니다.


예상 질문
Vueroid Cloud 프로젝트에서 Redis Pub/Sub을 활용해 웹소켓 세션을 관리했다고 하셨는데, 메시지 유실 가능성에 대해서는 어떻게 고려하셨나요? Kafka가 아닌 Redis를 선택한 구체적인 이유는 무엇인가요?
Blur 프로젝트에서 발생한 동시성 문제는 구체적으로 어떤 상황이었으며, 적용하신 락(Lock) 방식이 트래픽이 몰리는 상황에서 DB 성능에 미치는 영향은 어떻게 판단하셨나요?
ADAS Dataset 프로젝트에서 커서 기반(No-Offset) 페이징을 구현하실 때, 정렬 기준이 중복되는 경우(예: 생성일시가 같은 경우)에는 커서를 어떻게 설계하여 데이터를 누락 없이 조회하셨나요?