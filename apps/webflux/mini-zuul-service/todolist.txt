Phase 1: HTTP 통신 기초 공사 (현재 단계)
가장 먼저, TCP 바이트 스트림을 우리가 이해할 수 있는 HTTP 객체로 변환하고, 요청이 제대로 들어오는지 확인해야 합니다.

HttpServerCodec 등록:

Netty가 제공하는 기본 코덱입니다. 들어오는 ByteBuf를 HttpRequest로 변환하고, 나가는 HttpResponse를 ByteBuf로 변환합니다.

HttpObjectAggregator 등록:

HTTP 요청은 헤더와 바디가 조각(Chunk)나서 들어올 수 있습니다. 이를 하나의 온전한 FullHttpRequest 객체로 합쳐주는 핸들러입니다. (개발 편의성을 위해 초기 필수)

LoggerHandler (임시):

요청이 파이프라인을 타고 들어오는 과정을 눈으로 확인하기 위한 디버깅용 핸들러입니다.

Phase 2: 프록시 코어 로직 (단순 중계)
클라이언트의 요청을 받아 백엔드 서버로 넘겨주는 핵심 로직입니다. 여기서부터는 Netty Client 기능이 포함됩니다.

ProxyFrontendHandler 구현 (핵심):

역할: 클라이언트와 연결된 채널(Inbound Channel)을 관리합니다.

기능:

요청이 들어오면 백엔드 서버로 연결을 시도합니다 (Bootstrap 사용).

백엔드 연결이 완료될 때까지 들어오는 요청 읽기를 잠시 멈춥니다 (AutoRead 제어).

ProxyBackendHandler 구현:

역할: 프록시와 백엔드 서버 간의 연결 채널(Outbound Channel)을 관리합니다.

기능:

백엔드에서 응답이 오면, 이를 클라이언트 채널로 토스합니다.

백엔드 연결이 끊기면 클라이언트 연결도 같이 끊습니다.

Phase 3: 데이터 무결성 및 흐름 제어
단순히 데이터를 넘기는 것을 넘어, 올바른 프록시 동작을 위한 정교한 제어를 추가합니다.

헤더 조작 (Header Manipulation):

Host 헤더 변조: 백엔드 서버가 인식할 수 있도록 Host 헤더를 수정합니다.

X-Forwarded-For 추가: 백엔드 서버가 원본 클라이언트의 IP를 알 수 있도록 헤더를 추가합니다.

Flow Control (백프레셔 처리):

클라이언트가 보내는 속도가 백엔드가 받는 속도보다 빠를 때(또는 그 반대), 메모리가 터지지 않도록 읽기 속도를 조절하는 로직을 추가합니다 (channelWritabilityChanged 활용).

Phase 4: 기능 확장 (Advanced)
기본적인 프록시 기능이 완성된 후, Zuul과 같은 기능을 덧붙입니다.

비동기 요청 로그 (Access Log):

I/O 쓰레드(EventLoop)를 방해하지 않으면서 파일에 접속 로그를 남기는 비동기 로거를 구현합니다.

로드 밸런싱 (Load Balancing):

백엔드 서버 목록을 List로 관리하고, 요청마다 라운드 로빈(Round Robin) 방식으로 타겟 서버를 선택하는 로직을 추가합니다.